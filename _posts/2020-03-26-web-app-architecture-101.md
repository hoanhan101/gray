---
layout: post
title: Web Application Architecture 101
summary: A comprehensive insight into the web application architecture including client-server, peer to peer decentralized architecture, microservices, and so on
category: System-design-notes
tags: [architecture]
---

- Tiers 
  - A tier is a logical separation of components in an application or service - database, backend app, user interface, messaging, caching
  - Single tier: user interface, backend business logic, database reside in the same machine
    - Pros: no network latency
    - Cons: hard to maintain once is shipped
  - Two-tier: client (user interface, business logic) & server (database)
    - Communication happens over the HTTP protocol (request-response model & stateless)
    - REST API takes advantage of the HTTP methodologies to establish communication between the client and the server
  - Three-tier: user interface, application logic, database reside in different machines
  - N-tier: more than 3 components involved - cache, message queues, load balancers,...
    - Single Responsibility Principle: a component has only a single responsibility 
    - Separation of concerns: keep components separate, make them reusable
- Scalability
  - Ability to withstand increased workload without sacrificing the latency
  - Latency an be divided into 2 parts:
    - Network latency: amount of time the network takes to send data packet from point A to B
    - Application latency: amount of time the application takes to process a user request
  - Type of scalability
    - Vertical scaling/scaling up: adding more power to server
      - Pros: not a lot of overhead on monitoring, operating and maintaining
      - Cons: single point of failure
    - Horizontal scaling/scaling out: adding more hardware to the existing resource pool
      - Pros: cheaper, better fault-tolerance
      - Cons: managing server is hard, writing distributed computing program is also challenging
  - Common bottlenecks that hurt scalability
    - Database latency
    - Poor application architecture
    - Not caching wisely
    - Inefficient configuration and load balancing
    - Adding business logic to the database
    - Badly written code
  - Common strategies to improve and test the scalability
    - Profiling
    - Cache wisely
    - Use a CDN
    - Compress data
    - Avoid unnecessary round trips between client and sever
    - Run load & stress tests
- High Availability
  - Ability to stay online despite having failures at the infrastructural level in real-time
  - Common reasons for system failures
    - Software crashes
    - Hardware crashes
    - Human error
    - Planned downtime
  - A common way to add more availability is to have redundancy - duplicating the components & keeping them on standby to take over in case the active instances go down
- Monolithic & Microservices
  - Monolithic: entire application code in a single service
    - Pros: simple to develop, test, deploy as everything resides in one repo
    - Cons:
      - Continuous deployment means re-deploying the entire application
      - Single point of failure
      - Hard to scale
  - Microservices: tasks are split into separate services forming a larger service as a whole
    - Pros:
      - No single point of failure
      - Easier to scale independently
    - Cons:
      - Difficult to manage
      - No strong consistency
- Database
  - Forms of data:
    - Structured: conforms to a certain structure, stored in a normalized fashion
    - Unstructured: no definite structure, could be text, image, video, multimedia files, machine-generated data
    - Semi-structured: mix of structured and unstructured data, stored in XML or JSON
    - User state: user logs and activity on the platform
  - Why the need for NoSQL while relational database is still doing fine?
    - Scaling relational database is not trivial, which requires Sharding or Replicating
    - NoSQL is fast with read-write and really easy to scale out
    - Eventual consistency over strong consistency
      - Eventual consistency: achieve high availability that informally guarantees that, if no new updates are made, return the last updated value for all accesses
      - Strong consistency: data has to be strongly consistent at all times
    - Data analytics
  - Polyglot persistence
    - Use different storage technologies to handle different needs within a given software application
    - Multi-model databases reduce the operational complexity of using several different database models in an application by supporting multiple data models via a single API
  - CAP theorem
    - It is impossible for a distributed data store to simultaneously provide more than two out of the following three guarantees:
      - Consistency: every read receives the most recent write
      - Availability: every request receives a non-error response
      - Partition tolerance: system continues to operate despite network failures
  - Types of databases
    - Document-oriented: generally semi-structured & stored in a JSON-like format
      - Use cases:
        - Working with semi-structured data
        - Need a flexible schema
        - Examples are real-time feeds, live sport apps, web-based multiplayer games
      - Real life implementations
        - [SEGA uses Mongo-DB to simply ops and improve gaming experiences](https://www.mongodb.com/blog/post/sega-hardlight-migrates-to-mongodb-atlas-simplify-ops-improve-experience-mobile-gamers)
        - [Coinbase uses MongoDB to scale from 15k to 1.2 million requests per minute](https://www.mongodb.com/customers/coinbase)
    - Graph: store data in nodes/vertices and edges in the form of relationships
      - Use cases:
        - Maps
        - Social graphs
        - Recommendation engines
        - Storing genetic data
      - Real life implementations
        - [Walmart uses Neo4J to show product recommendations in real-time](https://neo4j.com/case-studies/walmart/)
        - [NASA uses Neo4J to store "lessons learned" data](https://neo4j.com/blog/david-meza-chief-knowledge-architect-nasa/)
    - Key-value: use a simple key-value method to store and quickly fetch the data
      - Use cases:
        - Caching
        - Implementing queue
        - Managing real-time data
      - Real life implementations
        - [Inovonics uses Redis to drive real-time analytics on millions of sensor data](https://redislabs.com/customers/inovonics/)
        - [Microsoft uses Redis to handle the traffic spike on its platforms](https://redislabs.com/docs/microsoft-relies-redis-labs/)
        - [Google Cloud uses Memcache to implement caching on their cloud platform](https://cloud.google.com/appengine/docs/standard/python/memcache/)
    - Time series: optimized for tracking & persisting time series data
      - Use cases:
        - Managing data in real-time & continually over a long period of time
        - Managing data for running analytics & monitoring
      - Real life implementations
        - [IBM uses Influx DB to run analytics for real-time cognitive fraud detection](https://www.influxdata.com/customer/ibm/)
        - [Spiio uses Influx DB to remotely monitor vertical lining green walls & plant installations](https://www.influxdata.com/customer/customer_case_study_spiio/)
    - Wide Column: primarily used to handle massive amounts of data
      - Use cases:
        - Managing big data
      - Real life implementations
        - [Netflix uses Cassandra as the backend database for the streaming service](https://netflixtechblog.com/tagged/cassandra)
        - [Adobe uses HBase for processing large amounts of data](https://hbase.apache.org/poweredbyhbase.html)


<br>
**References:**
- [https://www.educative.io/courses/web-application-software-architecture-101](https://www.educative.io/courses/web-application-software-architecture-101)
