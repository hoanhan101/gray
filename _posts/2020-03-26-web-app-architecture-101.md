---
layout: post
title: Web Application Architecture 101
summary: A comprehensive insight into the web application architecture including client-server, peer to peer decentralized architecture, microservices, and so on
category: System-design-notes
tags: [architecture]
---

- Tiers 
  - A tier is a logical separation of components in an application or service - database, backend app, user interface, messaging, caching
  - Single tier: user interface, backend business logic, database reside in the same machine
    - Pros: no network latency
    - Cons: hard to maintain once is shipped
  - Two-tier: client (user interface, business logic) & server (database)
    - Communication happens over the HTTP protocol (request-response model & stateless)
    - REST API takes advantage of the HTTP methodologies to establish communication between the client and the server
  - Three-tier: user interface, application logic, database reside in different machines
  - N-tier: more than 3 components involved - cache, message queues, load balancers,...
    - Single Responsibility Principle: a component has only a single responsibility 
    - Separation of concerns: keep components separate, make them reusable
- Scalability
  - Ability to withstand increased workload without sacrificing the latency
  - Latency an be divided into 2 parts:
    - Network latency: amount of time the network takes to send data packet from point A to B
    - Application latency: amount of time the application takes to process a user request
  - Type of scalability
    - Vertical scaling/scaling up: adding more power to server
      - Pros: not a lot of overhead on monitoring, operating and maintaining
      - Cons: single point of failure
    - Horizontal scaling/scaling out: adding more hardware to the existing resource pool
      - Pros: cheaper, better fault-tolerance
      - Cons: managing server is hard, writing distributed computing program is also challenging
  - Common bottlenecks that hurt scalability
    - Database latency
    - Poor application architecture
    - Not caching wisely
    - Inefficient configuration and load balancing
    - Adding business logic to the database
    - Badly written code
  - Common strategies to improve and test the scalability
    - Profiling
    - Cache wisely
    - Use a CDN
    - Compress data
    - Avoid unnecessary round trips between client and sever
    - Run load & stress tests
- High Availability
  - Ability to stay online despite having failures at the infrastructural level in real-time
  - Common reasons for system failures
    - Software crashes
    - Hardware crashes
    - Human error
    - Planned downtime
  - A common way to add more availability is to have redundancy - duplicating the components & keeping them on standby to take over in case the active instances go down
- Monolithic & Microservices
  - Monolithic: entire application code in a single service
    - Pros: simple to develop, test, deploy as everything resides in one repo
    - Cons:
      - Continuous deployment means re-deploying the entire application
      - Single point of failure
      - Hard to scale
  - Microservices: tasks are split into separate services forming a larger service as a whole
    - Pros:
      - No single point of failure
      - Easier to scale independently
    - Cons:
      - Difficult to manage
      - No strong consistency
- Database
  - Forms of data:
    - Structured: conforms to a certain structure, stored in a normalized fashion
    - Unstructured: no definite structure, could be text, image, video, multimedia files, machine-generated data
    - Semi-structured: mix of structured and unstructured data, stored in XML or JSON
    - User state: user logs and activity on the platform
  - Why the need for NoSQL while relational database is still doing fine?
    - Scaling relational database is not trivial, which requires Sharding or Replicating
    - NoSQL is fast with read-write and really easy to scale out
    - Eventual consistency over strong consistency
      - Eventual consistency: achieve high availability that informally guarantees that, if no new updates are made, return the last updated value for all accesses
      - Strong consistency: data has to be strongly consistent at all times
    - Data analytics
  - Polyglot persistence
    - Use different storage technologies to handle different needs within a given software application
    - Multi-model databases reduce the operational complexity of using several different database models in an application by supporting multiple data models via a single API
  - CAP theorem
    - It is impossible for a distributed data store to simultaneously provide more than two out of the following three guarantees:
      - Consistency: every read receives the most recent write
      - Availability: every request receives a non-error response
      - Partition tolerance: system continues to operate despite network failures
  - Types of databases
    - Document-oriented: generally semi-structured & stored in a JSON-like format
      - Use cases:
        - Work with semi-structured data
        - Need a flexible schema
        - Examples are real-time feeds, live sport apps, web-based multiplayer games
      - Real life implementations
        - [SEGA uses Mongo-DB to improve the experience for millions of mobile gamers](https://www.mongodb.com/blog/post/sega-hardlight-migrates-to-mongodb-atlas-simplify-ops-improve-experience-mobile-gamers)
        - [Coinbase scaled from 15k requests per min to 1.2 million requests per minute with MongoDB](https://www.mongodb.com/customers/coinbase)


<br>
**References:**
- [https://www.educative.io/courses/web-application-software-architecture-101](https://www.educative.io/courses/web-application-software-architecture-101)
